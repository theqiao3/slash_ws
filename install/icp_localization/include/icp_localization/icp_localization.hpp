/**
 * @file icp_localization.hpp
 * @brief ICP-based localization node for Ackermann robot
 * @details This node provides map->odom transform estimation using ICP algorithm
 *          with PCD point cloud map generated by FAST_LIO
 */

#ifndef ICP_LOCALIZATION__ICP_LOCALIZATION_HPP_
#define ICP_LOCALIZATION__ICP_LOCALIZATION_HPP_

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <geometry_msgs/msg/pose_with_covariance_stamped.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <nav_msgs/msg/path.hpp>
#include <std_srvs/srv/trigger.hpp>
#include <visualization_msgs/msg/marker.hpp>

#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2/LinearMath/Matrix3x3.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/registration/icp.h>
#include <pcl/registration/ndt.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl_conversions/pcl_conversions.h>

#include <Eigen/Dense>
#include <mutex>
#include <thread>
#include <atomic>
#include <deque>

namespace icp_localization
{

using PointT = pcl::PointXYZI;
using PointCloudT = pcl::PointCloud<PointT>;

/**
 * @class ICPLocalization
 * @brief ICP-based localization class for providing map->odom transform
 */
class ICPLocalization : public rclcpp::Node
{
public:
  /**
   * @brief Constructor
   * @param options Node options
   */
  explicit ICPLocalization(const rclcpp::NodeOptions & options = rclcpp::NodeOptions());

  /**
   * @brief Destructor
   */
  ~ICPLocalization();

private:
  // Initialization
  void declareParameters();
  void loadParameters();
  bool loadPCDMap();
  void setupPublishersSubscribers();
  void setupTimers();

  // Callbacks
  void pointCloudCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg);
  void odomCallback(const nav_msgs::msg::Odometry::SharedPtr msg);
  void initialPoseCallback(const geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr msg);
  void timerCallback();

  // Core localization functions
  bool performICP(const PointCloudT::Ptr & source_cloud, Eigen::Matrix4f & result_transform, const Eigen::Matrix4f & initial_guess);
  void updateTransform();
  void publishTransform();
  void publishAlignedCloud(const PointCloudT::Ptr & cloud);
  void publishMapCloud();
  void publishPosePath();
  
  // Helper functions
  PointCloudT::Ptr preprocessCloud(const PointCloudT::Ptr & input_cloud);
  PointCloudT::Ptr cropCloud(const PointCloudT::Ptr & input_cloud, const Eigen::Vector3f & center, float radius);
  double calculateFitnessScore(const PointCloudT::Ptr & cloud);
  Eigen::Matrix4f poseToMatrix(const geometry_msgs::msg::Pose & pose);
  geometry_msgs::msg::Pose matrixToPose(const Eigen::Matrix4f & matrix);
  
  // Service callbacks
  void relocalizationCallback(
    const std::shared_ptr<std_srvs::srv::Trigger::Request> request,
    std::shared_ptr<std_srvs::srv::Trigger::Response> response);

  // Parameters
  std::string pcd_map_path_;
  std::string odom_frame_;
  std::string base_frame_;
  std::string map_frame_;
  std::string lidar_frame_;
  std::string lidar_topic_;
  std::string odom_topic_;
  
  double voxel_leaf_size_;
  double map_voxel_leaf_size_;
  double icp_max_correspondence_distance_;
  int icp_max_iterations_;
  double icp_transformation_epsilon_;
  double icp_euclidean_fitness_epsilon_;
  double icp_ransac_outlier_threshold_;
  
  double min_scan_range_;
  double max_scan_range_;
  double local_map_radius_;
  
  double transform_publish_rate_;
  double map_publish_rate_;
  
  double fitness_score_threshold_;
  bool use_initial_pose_;
  
  // Point cloud data
  PointCloudT::Ptr global_map_;
  PointCloudT::Ptr local_map_;
  PointCloudT::Ptr current_scan_;
  pcl::KdTreeFLANN<PointT>::Ptr map_kdtree_;
  
  // Transform data
  Eigen::Matrix4f map_to_odom_;
  Eigen::Matrix4f current_pose_;  // in map frame
  Eigen::Matrix4f last_odom_pose_;
  bool has_initial_pose_;
  bool has_odom_;
  
  std::mutex pose_mutex_;
  std::mutex cloud_mutex_;
  
  // TF2
  std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
  std::shared_ptr<tf2_ros::Buffer> tf_buffer_;
  std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
  
  // Publishers
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr aligned_cloud_pub_;
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr map_cloud_pub_;
  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr current_pose_pub_;
  rclcpp::Publisher<nav_msgs::msg::Path>::SharedPtr path_pub_;
  rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr marker_pub_;
  
  // Subscribers
  rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr pointcloud_sub_;
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
  rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr initial_pose_sub_;
  
  // Timers
  rclcpp::TimerBase::SharedPtr transform_timer_;
  rclcpp::TimerBase::SharedPtr map_timer_;
  
  // Services
  rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr relocalize_service_;
  
  // Path history
  nav_msgs::msg::Path pose_path_;
  
  // ICP object
  pcl::IterativeClosestPoint<PointT, PointT> icp_;
  
  // Stats
  std::atomic<int> successful_matches_{0};
  std::atomic<int> failed_matches_{0};
  double last_fitness_score_{0.0};
};

}  // namespace icp_localization

#endif  // ICP_LOCALIZATION__ICP_LOCALIZATION_HPP_
